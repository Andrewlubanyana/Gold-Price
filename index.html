<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering Elliott Wave - Gold Chart</title>
    <style>
        /* --- CSS: DARK PROFESSIONAL THEME --- */
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #1e1e1e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .title-group h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #d4af37; /* Gold */
            letter-spacing: 1px;
        }
        .title-group span { font-size: 0.8rem; color: #777; }

        .controls { display: flex; gap: 10px; }
        
        button {
            background: #2a2a2a; color: #aaa;
            border: 1px solid #333;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            transition: 0.2s;
        }
        button:hover { background: #333; color: #fff; }
        button.active { background: #d4af37; color: #000; border-color: #d4af37; font-weight: bold; }

        .price-display { text-align: right; }
        #current-price { font-size: 1.4rem; font-weight: bold; color: #fff; }
        #status { font-size: 0.75rem; color: #555; }

        /* CHART CONTAINER */
        #chart-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* Floating Labels */
        .float-label {
            position: absolute;
            padding: 4px 6px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #444;
            color: #fff;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <header>
        <div class="title-group">
            <h1>GOLD / USD</h1>
            <span>Strict Elliott Wave Principle (C. Brown)</span>
        </div>
        <div class="controls">
            <button class="active" onclick="app.changeTF('1m', 1)">1m</button>
            <button onclick="app.changeTF('15m', 15)">15m</button>
            <button onclick="app.changeTF('1h', 60)">1H</button>
            <button onclick="app.changeTF('4h', 240)">4H</button>
            <button onclick="app.changeTF('1d', 1440)">1D</button>
        </div>
        <div class="price-display">
            <div id="current-price">---.--</div>
            <div id="status">Initializing...</div>
        </div>
    </header>

    <div id="chart-container">
        <canvas id="mainCanvas"></canvas>
        <div id="tooltip-price" class="float-label" style="right: 0;"></div>
        <div id="tooltip-time" class="float-label" style="bottom: 0;"></div>
    </div>

    <script>
        /**
         * ELLIOT WAVE ENGINE - STRICT RULES IMPLEMENTATION
         * Based on "Mastering Elliott Wave Principle"
         */

        const CONFIG = {
            colors: {
                bg: '#121212',
                grid: '#1f1f1f',
                candleUp: '#089981',
                candleDown: '#f23645',
                text: '#666',
                impulseLabel: '#00b0ff', // Blue for 1-2-3-4-5
                correctLabel: '#ff9800'  // Orange for A-B-C
            },
            padding: { right: 60, bottom: 25 },
            minCandleWidth: 2,
            maxCandleWidth: 100
        };

        class App {
            constructor() {
                this.data = [];
                this.waves = [];
                
                this.view = {
                    tf: '1m', agg: 1,
                    offset: 0,
                    zoom: 10,
                    scaleY: 1.0,
                    shiftY: 0,
                    autoScale: true
                };

                this.input = { dragging: false, lastX: 0, mouseX: 0, mouseY: 0 };
                
                this.dom = {
                    cvs: document.getElementById('mainCanvas'),
                    ctx: document.getElementById('mainCanvas').getContext('2d', { alpha: false }),
                    cnt: document.getElementById('chart-container'),
                    price: document.getElementById('current-price'),
                    status: document.getElementById('status'),
                    tipP: document.getElementById('tooltip-price'),
                    tipT: document.getElementById('tooltip-time')
                };

                this.initEvents();
                this.resize();
                this.fetchData();
            }

            // --- 1. DATA FETCHING ---
            async changeTF(tf, agg) {
                this.view.tf = tf; this.view.agg = agg;
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                await this.fetchData();
            }

            async fetchData() {
                this.dom.status.innerText = "Analyzing Market Structure...";
                try {
                    let ep = 'histominute';
                    let limit = 2000;
                    let agg = this.view.agg;
                    
                    if(agg >= 60) { ep = 'histohour'; agg /= 60; }
                    if(agg >= 1440) { ep = 'histoday'; agg = 1; }

                    const url = `https://min-api.cryptocompare.com/data/v2/${ep}?fsym=PAXG&tsym=USD&limit=${limit}&aggregate=${agg}`;
                    const res = await fetch(url);
                    const json = await res.json();

                    if(json.Response === 'Success') {
                        this.data = json.Data.Data.map(d => ({
                            t: d.time, o: d.open, h: d.high, l: d.low, c: d.close
                        }));
                        
                        // Initial Setup
                        this.view.offset = 0;
                        this.dom.price.innerText = this.data[this.data.length-1].c.toFixed(2);
                        this.dom.status.innerText = "Live";
                        
                        this.runElliotWaveEngine();
                        this.draw();
                    }
                } catch(e) {
                    this.dom.status.innerText = "Data Error (Check Connection)";
                    console.error(e);
                }
            }

            // --- 2. ELLIOT WAVE LOGIC (THE BRAIN) ---
            runElliotWaveEngine() {
                if(this.data.length < 20) return;
                this.waves = [];

                // A. IDENTIFY PIVOTS (ZigZag)
                // Filter "Swings" from noise (Page 13)
                // We use a dynamic deviation based on the volatility of the visible range
                const pivots = this.getPivots(this.data, 5); // 5-bar lookback for sensitivity

                // B. PATTERN RECOGNITION (Iterate Pivots)
                // We look for 5-wave Impulse sequences followed by 3-wave Corrections
                
                let i = 0;
                while(i < pivots.length - 8) { // Need enough points for 1-5 and A-B-C
                    
                    // Attempt to find Bullish Impulse (1-2-3-4-5)
                    const p0 = pivots[i];
                    const p1 = pivots[i+1];
                    const p2 = pivots[i+2];
                    const p3 = pivots[i+3];
                    const p4 = pivots[i+4];
                    const p5 = pivots[i+5];

                    // Direction Check: Low-High-Low-High-Low-High
                    if(p1.v > p0.v && p2.v < p1.v && p3.v > p2.v && p4.v < p3.v && p5.v > p4.v) {
                        
                        // --- RULE 1: Wave 2 cannot retrace 100% of Wave 1 ---
                        if(p2.v <= p0.v) { i++; continue; }

                        // --- RULE 3: Wave 4 cannot overlap Wave 1 ---
                        // (Strict adherence as per user request)
                        if(p4.v <= p1.v) { i++; continue; }

                        // --- RULE 2: Wave 3 cannot be the shortest ---
                        const len1 = Math.abs(p1.v - p0.v);
                        const len3 = Math.abs(p3.v - p2.v);
                        const len5 = Math.abs(p5.v - p4.v);
                        if(len3 < len1 && len3 < len5) { i++; continue; }

                        // If valid, register the Impulse
                        this.waves.push({ type: 'impulse', pts: [p1, p2, p3, p4, p5] });
                        
                        // Look for Correction (A-B-C) immediately following
                        const pa = pivots[i+6];
                        const pb = pivots[i+7];
                        const pc = pivots[i+8];

                        // Simple Check: Down-Up-Down
                        if(pa.v < p5.v && pb.v > pa.v && pc.v < pb.v) {
                            // Check Zigzag rule: B usually doesn't exceed start of A (Wave 5)
                            // Allowing Flats (where B ends near 5)
                            if(pb.v < p5.v * 1.01) { 
                                this.waves.push({ type: 'correct', pts: [pa, pb, pc] });
                                i += 8; // Skip identified patterns
                                continue;
                            }
                        }
                        
                        i += 5; // Skip the impulse
                        continue;
                    }

                    // Attempt Bearish Impulse (Inverse Rules)
                    if(p1.v < p0.v && p2.v > p1.v && p3.v < p2.v && p4.v > p3.v && p5.v < p4.v) {
                        // Rule 1
                        if(p2.v >= p0.v) { i++; continue; }
                        // Rule 3
                        if(p4.v >= p1.v) { i++; continue; }
                        // Rule 2
                        const len1 = Math.abs(p0.v - p1.v);
                        const len3 = Math.abs(p2.v - p3.v);
                        const len5 = Math.abs(p4.v - p5.v);
                        if(len3 < len1 && len3 < len5) { i++; continue; }

                        this.waves.push({ type: 'impulse_bear', pts: [p1, p2, p3, p4, p5] });
                        i += 5;
                        continue;
                    }

                    i++;
                }
            }

            getPivots(data, leftRightBars) {
                // Simplified Swing detection
                let pivots = [];
                for(let i = leftRightBars; i < data.length - leftRightBars; i++) {
                    const high = data[i].h;
                    const low = data[i].l;
                    
                    // Is Pivot High?
                    let isHigh = true;
                    for(let k=1; k<=leftRightBars; k++) {
                        if(data[i-k].h > high || data[i+k].h > high) isHigh = false;
                    }
                    if(isHigh) pivots.push({ i: i, v: high, type: 'H' });

                    // Is Pivot Low?
                    let isLow = true;
                    for(let k=1; k<=leftRightBars; k++) {
                        if(data[i-k].l < low || data[i+k].l < low) isLow = false;
                    }
                    if(isLow) pivots.push({ i: i, v: low, type: 'L' });
                }
                return pivots;
            }

            // --- 3. RENDERING ENGINE ---
            draw() {
                const ctx = this.dom.ctx;
                const W = this.dom.cnt.clientWidth;
                const H = this.dom.cnt.clientHeight;
                
                // Reset
                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0,0,W,H);
                
                if(this.data.length === 0) return;

                // Viewport Calculations
                const chartW = W - CONFIG.padding.right;
                const chartH = H - CONFIG.padding.bottom;
                const zoom = this.view.zoom;
                
                const visibleBars = Math.floor(chartW / zoom);
                let endIdx = this.data.length - 1 - Math.floor(this.view.offset);
                let startIdx = endIdx - visibleBars;
                if(endIdx >= this.data.length) endIdx = this.data.length - 1;
                if(startIdx < 0) startIdx = 0;

                const viewData = this.data.slice(startIdx, endIdx + 1);
                
                // Y-Axis Scaling
                let min = Infinity, max = -Infinity;
                for(let d of viewData) {
                    if(d.l < min) min = d.l;
                    if(d.h > max) max = d.h;
                }
                
                // Auto Scale Logic
                if(this.view.autoScale) {
                    const pad = (max - min) * 0.1;
                    this.minP = min - pad;
                    this.maxP = max + pad;
                } else {
                    const mid = (min + max) / 2 + this.view.shiftY;
                    const range = (max - min) / this.view.scaleY;
                    this.minP = mid - range/2;
                    this.maxP = mid + range/2;
                }
                const pRange = this.maxP - this.minP;

                // Coordinate Converters
                const toX = (i) => chartW - ((endIdx - i + 0.5) * zoom);
                const toY = (p) => chartH - ((p - this.minP) / pRange * chartH);

                // --- LAYERS ---

                // 1. Grid
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Price Grid
                for(let i=0; i<6; i++) {
                    let p = this.minP + (pRange * (i/5));
                    let y = toY(p);
                    ctx.moveTo(0, y); ctx.lineTo(chartW, y);
                    // Axis Label
                    ctx.fillStyle = CONFIG.colors.text;
                    ctx.font = "11px Arial";
                    ctx.fillText(p.toFixed(2), chartW + 5, y + 4);
                }
                ctx.stroke();

                // 2. Dynamic Date/Time Axis
                ctx.beginPath();
                const timeStep = Math.max(1, Math.floor(100 / zoom)); // Don't overlap text
                for(let i = startIdx; i <= endIdx; i++) {
                    if(i % timeStep === 0) {
                        let x = toX(i);
                        let date = new Date(this.data[i].t * 1000);
                        let label = "";
                        
                        // Dynamic Format based on zoom/TF
                        if(this.view.tf === '1d') {
                            label = `${date.getDate()}/${date.getMonth()+1}`; // D/M
                        } else {
                            let hrs = date.getHours().toString().padStart(2,'0');
                            let min = date.getMinutes().toString().padStart(2,'0');
                            label = `${hrs}:${min}`;
                            if(hrs === '00' && min === '00') label = `${date.getDate()}/${date.getMonth()+1}`;
                        }

                        ctx.moveTo(x, 0); ctx.lineTo(x, chartH + 5);
                        ctx.fillStyle = CONFIG.colors.text;
                        ctx.fillText(label, x - 10, chartH + 15);
                    }
                }
                ctx.strokeStyle = '#222';
                ctx.stroke();

                // 3. Candles
                const bodyW = Math.max(1, zoom * 0.8);
                for(let i=startIdx; i<=endIdx; i++) {
                    const d = this.data[i];
                    const x = toX(i);
                    const yO = toY(d.o);
                    const yC = toY(d.c);
                    const yH = toY(d.h);
                    const yL = toY(d.l);

                    ctx.fillStyle = d.c >= d.o ? CONFIG.colors.candleUp : CONFIG.colors.candleDown;
                    ctx.strokeStyle = ctx.fillStyle;

                    ctx.beginPath();
                    ctx.moveTo(x, yH); ctx.lineTo(x, yL);
                    ctx.stroke();
                    ctx.fillRect(x - bodyW/2, Math.min(yO, yC), bodyW, Math.max(1, Math.abs(yO-yC)));
                }

                // 4. ELLIOT WAVE FIGURES (No Lines)
                ctx.font = "bold 13px Arial";
                ctx.textAlign = "center";

                for(let wave of this.waves) {
                    const isImpulse = wave.type.includes('impulse');
                    const color = isImpulse ? CONFIG.colors.impulseLabel : CONFIG.colors.correctLabel;
                    const labels = isImpulse ? ['1','2','3','4','5'] : ['A','B','C'];
                    
                    // Offset labels: Bullish numbers below low/above high
                    // Simple heuristic: If point is High, text above. If Low, text below.
                    
                    wave.pts.forEach((pt, idx) => {
                        if(pt.i >= startIdx && pt.i <= endIdx) {
                            const x = toX(pt.i);
                            const y = toY(pt.v);
                            
                            // Determine if this pivot is a High or Low relative to neighbors
                            // (Simplified for this view)
                            const isHigh = pt.type === 'H';
                            const yOffset = isHigh ? -12 : 20;

                            ctx.fillStyle = color;
                            ctx.fillText(labels[idx], x, y + yOffset);
                        }
                    });
                }

                // 5. Crosshair
                const mx = this.input.mouseX;
                const my = this.input.mouseY;
                if(mx > 0 && mx < chartW && my > 0 && my < chartH) {
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([4,4]);
                    ctx.beginPath();
                    ctx.moveTo(0, my); ctx.lineTo(chartW, my);
                    ctx.moveTo(mx, 0); ctx.lineTo(mx, chartH);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Tooltip Logic
                    const price = this.maxP - ((my / chartH) * pRange);
                    this.dom.tipP.style.display = "block";
                    this.dom.tipP.style.top = (my - 10) + "px";
                    this.dom.tipP.innerText = price.toFixed(2);

                    // Inverse X to Index
                    // x = chartW - ((endIdx - i + 0.5) * zoom)
                    // i = endIdx + 0.5 - (chartW - x) / zoom
                    const idx = Math.round(endIdx + 0.5 - (chartW - mx) / zoom);
                    if(this.data[idx]) {
                        const d = new Date(this.data[idx].t * 1000);
                        this.dom.tipT.style.display = "block";
                        this.dom.tipT.style.left = (mx - 40) + "px";
                        this.dom.tipT.innerText = d.toLocaleString();
                    }
                } else {
                    this.dom.tipP.style.display = "none";
                    this.dom.tipT.style.display = "none";
                }
            }

            // --- 4. INTERACTION ---
            initEvents() {
                const c = this.dom.cnt;
                
                c.addEventListener('mousedown', e => {
                    const rect = c.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    if(x > c.clientWidth - CONFIG.padding.right) {
                        this.view.autoScale = false; // Manual scale
                        c.style.cursor = 'ns-resize';
                    } else {
                        this.input.dragging = true;
                        c.style.cursor = 'grabbing';
                    }
                    this.input.lastX = e.clientX;
                    this.input.lastY = e.clientY;
                });

                window.addEventListener('mouseup', () => {
                    this.input.dragging = false;
                    c.style.cursor = 'crosshair';
                });

                c.addEventListener('mousemove', e => {
                    const rect = c.getBoundingClientRect();
                    this.input.mouseX = e.clientX - rect.left;
                    this.input.mouseY = e.clientY - rect.top;
                    
                    const dx = e.clientX - this.input.lastX;
                    const dy = e.clientY - this.input.lastY;
                    this.input.lastX = e.clientX;
                    this.input.lastY = e.clientY;

                    if(this.input.dragging) {
                        this.view.offset += dx / this.view.zoom;
                        if(this.view.offset < 0) this.view.offset = 0;
                    } else if (!this.view.autoScale && e.buttons === 1) {
                        // Manual Y Drag
                        this.view.scaleY += dy * -0.01;
                        if(this.view.scaleY < 0.1) this.view.scaleY = 0.1;
                    }
                    
                    this.draw();
                });

                c.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.view.zoom += (e.deltaY < 0 ? 1 : -1);
                    if(this.view.zoom < CONFIG.minCandleWidth) this.view.zoom = CONFIG.minCandleWidth;
                    if(this.view.zoom > CONFIG.maxCandleWidth) this.view.zoom = CONFIG.maxCandleWidth;
                    this.draw();
                }, { passive: false });

                c.addEventListener('dblclick', () => {
                    this.view.autoScale = true;
                    this.view.scaleY = 1.0;
                    this.view.shiftY = 0;
                    this.draw();
                });

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.dom.cvs.width = this.dom.cnt.clientWidth;
                this.dom.cvs.height = this.dom.cnt.clientHeight;
                this.draw();
            }
        }

        // Start Application
        const app = new App();

    </script>
</body>
</html>
