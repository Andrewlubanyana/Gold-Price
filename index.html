<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precision Gold Chart + Strict EWP</title>
    <style>
        body {
            background-color: #0d0d0d;
            color: #d1d4dc;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- HEADER --- */
        header {
            background-color: #161616;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a2a;
            flex-shrink: 0;
        }

        .left-panel { display: flex; align-items: center; gap: 20px; }
        
        h1 {
            margin: 0;
            font-size: 16px;
            color: #d4af37;
            font-weight: 700;
        }

        .tf-group { display: flex; background: #222; border-radius: 4px; padding: 2px; }
        .tf-btn {
            background: transparent; border: none; color: #777;
            padding: 4px 10px; font-size: 12px; font-weight: 600;
            cursor: pointer; border-radius: 2px; transition: 0.2s;
        }
        .tf-btn:hover { color: #fff; background: #333; }
        .tf-btn.active { color: #000; background: #d4af37; }

        .price-panel { text-align: right; }
        #price-display { font-size: 18px; font-weight: bold; color: #fff; }
        #status-display { font-size: 10px; color: #666; }

        /* --- CHART --- */
        #chart-container {
            flex-grow: 1;
            position: relative;
            background: #0d0d0d;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Floating Labels */
        .tooltip { position: absolute; display: none; pointer-events: none; z-index: 10; font-size: 11px; }
        #tip-price { right: 0; background: #d4af37; color: #000; padding: 2px 5px; font-weight: bold; }
        #tip-time { bottom: 30px; background: #333; color: #fff; padding: 4px 8px; border-radius: 2px; }

        #legend {
            position: absolute; top: 10px; left: 15px; pointer-events: none;
            font-size: 11px; color: #444;
        }
    </style>
</head>
<body>

    <header>
        <div class="left-panel">
            <h1>GOLD (XAU/USD)</h1>
            <div class="tf-group">
                <button class="tf-btn active" onclick="app.setTF('1m', 1)">1m</button>
                <button class="tf-btn" onclick="app.setTF('15m', 15)">15m</button>
                <button class="tf-btn" onclick="app.setTF('1h', 60)">1H</button>
                <button class="tf-btn" onclick="app.setTF('4h', 240)">4H</button>
                <button class="tf-btn" onclick="app.setTF('1d', 1440)">1D</button>
            </div>
        </div>
        <div class="price-panel">
            <div id="price-display">---.--</div>
            <div id="status-display">Initializing Engine...</div>
        </div>
    </header>

    <div id="chart-container">
        <canvas id="cvs"></canvas>
        <div id="tip-price" class="tooltip"></div>
        <div id="tip-time" class="tooltip"></div>
        <div id="legend">
            Mouse Wheel: Zoom X | Drag Right Scale: Zoom Y | Pan: Drag
        </div>
    </div>

    <script>
        /**
         * STRICT ELLIOT WAVE ENGINE & CHART
         */

        const CONFIG = {
            colors: {
                bg: '#0d0d0d',
                grid: '#1a1a1a',
                text: '#666',
                up: '#089981',
                down: '#f23645',
                waveLabelBull: '#00b0ff', // Blue for Bullish Counts
                waveLabelBear: '#ff9800'  // Orange for Bearish Counts
            },
            paddingRight: 60, // Space for price scale
            paddingBottom: 30 // Space for time scale
        };

        class ChartApp {
            constructor() {
                // State
                this.data = [];
                this.waves = [];
                this.view = {
                    tf: '1m', agg: 1,
                    offset: 0,
                    zoom: 12, // Candle width
                    scaleY: 1.0,
                    shiftY: 0,
                    autoScale: true
                };

                this.input = { dragging: false, resizingY: false, lastX: 0, lastY: 0, mouseX:0, mouseY:0 };
                
                // DOM
                this.dom = {
                    container: document.getElementById('chart-container'),
                    canvas: document.getElementById('cvs'),
                    ctx: document.getElementById('cvs').getContext('2d', {alpha: false}),
                    price: document.getElementById('price-display'),
                    status: document.getElementById('status-display'),
                    tipP: document.getElementById('tip-price'),
                    tipT: document.getElementById('tip-time')
                };

                this.initListeners();
                this.resize();
                this.fetchData();
            }

            // --- 1. STRICT ELLIOT WAVE ANALYSIS ---
            analyzeEWP() {
                if(this.data.length < 10) return;
                
                // A. Get Pivots (ZigZag)
                // Sensitivity auto-adjustment based on Timeframe to clean noise
                let deviation = 0.3; 
                if(this.view.tf === '1m') deviation = 0.2;
                if(this.view.tf === '15m') deviation = 1.0;
                if(this.view.tf === '1h') deviation = 2.5;
                if(this.view.tf === '1d') deviation = 15.0;

                const pivots = this.calculateZigZag(deviation);
                this.waves = [];

                if(pivots.length < 6) return;

                // B. Iterate Pivots looking for 5-wave Impulse structures
                for(let i = 0; i < pivots.length - 5; i++) {
                    const p0 = pivots[i];   // Start
                    const p1 = pivots[i+1]; // W1
                    const p2 = pivots[i+2]; // W2
                    const p3 = pivots[i+3]; // W3
                    const p4 = pivots[i+4]; // W4
                    const p5 = pivots[i+5]; // W5

                    // Check Directions
                    const isBull = p1.v > p0.v;
                    
                    // Basic Structure check (High-Low-High...)
                    if(isBull) {
                        if(p2.v >= p1.v || p3.v <= p2.v || p4.v >= p3.v || p5.v <= p4.v) continue;
                    } else {
                        if(p2.v <= p1.v || p3.v >= p2.v || p4.v <= p3.v || p5.v >= p4.v) continue;
                    }

                    // --- THE 3 STRICT RULES ---
                    
                    // 1. Wave 2 cannot retrace 100% of Wave 1
                    if(isBull && p2.v <= p0.v) continue;
                    if(!isBull && p2.v >= p0.v) continue;

                    // 2. Wave 4 cannot enter territory of Wave 1
                    // (Allowing for slight "wicks" but closing prices usually matter most. We use High/Low here for strictness)
                    if(isBull && p4.v <= p1.v) continue; 
                    if(!isBull && p4.v >= p1.v) continue;

                    // 3. Wave 3 cannot be the shortest
                    const len1 = Math.abs(p1.v - p0.v);
                    const len3 = Math.abs(p3.v - p2.v);
                    const len5 = Math.abs(p5.v - p4.v);
                    
                    if(len3 < len1 && len3 < len5) continue;

                    // If we passed all rules, save it
                    this.waves.push({
                        type: isBull ? 'bull' : 'bear',
                        points: [p1, p2, p3, p4, p5]
                    });
                    
                    // Skip ahead to avoid cluttered overlapping counts
                    i += 3; 
                }
            }

            calculateZigZag(dev) {
                let pivots = [];
                let dir = 0; 
                let lastP = this.data[0];
                let lastIdx = 0;
                
                pivots.push({i:0, v:this.data[0].o, t:this.data[0].t}); // anchor

                for(let i=1; i<this.data.length; i++) {
                    const c = this.data[i];
                    if(dir === 0) {
                        if(c.c > lastP.c + dev) dir = 1;
                        if(c.c < lastP.c - dev) dir = -1;
                        lastP = c; lastIdx = i;
                    } else if (dir === 1) { // Up
                        if(c.h > lastP.h) { lastP = c; lastIdx = i; }
                        else if(c.c < lastP.h - dev) { // Reverse down
                            pivots.push({i: lastIdx, v: lastP.h, t: lastP.t});
                            dir = -1; lastP = c; lastIdx = i;
                        }
                    } else { // Down
                        if(c.l < lastP.l) { lastP = c; lastIdx = i; }
                        else if(c.c > lastP.l + dev) { // Reverse up
                            pivots.push({i: lastIdx, v: lastP.l, t: lastP.t});
                            dir = 1; lastP = c; lastIdx = i;
                        }
                    }
                }
                // Add last point
                pivots.push({i: this.data.length-1, v: this.data[this.data.length-1].c, t: this.data[this.data.length-1].t});
                return pivots;
            }

            // --- 2. RENDERING ---
            draw() {
                const ctx = this.dom.ctx;
                const W = this.width;
                const H = this.height;
                const chartW = W - CONFIG.paddingRight;
                const chartH = H - CONFIG.paddingBottom;

                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0,0,W,H);

                if(this.data.length === 0) {
                    ctx.fillStyle = "#444"; ctx.fillText("Loading Data...", W/2-40, H/2); return;
                }

                // A. Viewport Calculations
                const zoom = this.view.zoom;
                const visCount = Math.ceil(chartW / zoom) + 1;
                let endIdx = this.data.length - 1 - Math.floor(this.view.offset);
                let startIdx = endIdx - visCount;
                if(endIdx >= this.data.length) endIdx = this.data.length-1;
                if(startIdx < 0) startIdx = 0;

                const viewData = this.data.slice(startIdx, endIdx+1);
                
                // Y-Axis Range
                let minP = Infinity, maxP = -Infinity;
                for(let c of viewData) { if(c.l<minP) minP=c.l; if(c.h>maxP) maxP=c.h; }
                
                // Manual Scale logic
                if(this.view.autoScale) {
                    const pad = (maxP - minP) * 0.1;
                    this.minP = minP - pad; this.maxP = maxP + pad;
                } else {
                    const mid = (minP+maxP)/2 + this.view.shiftY;
                    const rng = (maxP-minP) / this.view.scaleY;
                    this.minP = mid - rng/2; this.maxP = mid + rng/2;
                }
                const pRange = this.maxP - this.minP || 1;

                // Transforms
                const toX = (i) => chartW - ((endIdx - i + 0.5) * zoom);
                const toY = (v) => chartH - ((v - this.minP) / pRange * chartH);

                // B. Draw Grid & Price Scale (Right)
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for(let i=0; i<6; i++) {
                    const p = this.minP + (pRange*(i/5));
                    const y = toY(p);
                    ctx.moveTo(0, y); ctx.lineTo(chartW, y);
                    // Price Label
                    ctx.fillStyle = CONFIG.colors.text;
                    ctx.font = "11px Arial";
                    ctx.fillText(p.toFixed(2), chartW + 5, y+4);
                }
                ctx.stroke();

                // C. Draw Time Axis (Bottom) - Dynamic Date Formatter
                ctx.beginPath();
                // Determine label skip based on zoom to avoid overlap
                // approx 100px per label
                const pxPerLabel = 100;
                const skipCandles = Math.ceil(pxPerLabel / zoom); 
                
                for(let i=startIdx; i<=endIdx; i++) {
                    // Only draw if index matches skip pattern, aligned to logical times if possible
                    // Simplified: just modulus
                    if (i % skipCandles === 0) {
                        const x = toX(i);
                        if(x < 0) continue;
                        
                        const date = new Date(this.data[i].t * 1000);
                        let label = "";
                        
                        // Format based on TF
                        if(this.view.tf === '1m' || this.view.tf === '15m' || this.view.tf === '1h') {
                            // Time dominant
                            const h = date.getHours().toString().padStart(2,'0');
                            const m = date.getMinutes().toString().padStart(2,'0');
                            label = `${h}:${m}`;
                            // Add Day if it's 00:00
                            if(h === "00" && m === "00") label = date.getDate() + "/" + (date.getMonth()+1);
                        } else {
                            // Date dominant
                            label = date.getDate() + "/" + (date.getMonth()+1);
                        }

                        ctx.moveTo(x, 0); ctx.lineTo(x, chartH + 5); // Tick
                        ctx.fillStyle = CONFIG.colors.text;
                        ctx.textAlign = "center";
                        ctx.fillText(label, x, chartH + 15);
                    }
                }
                ctx.strokeStyle = '#222';
                ctx.stroke();


                // D. Draw Candles
                const bodyW = Math.max(1, zoom * 0.8);
                for(let i=startIdx; i<=endIdx; i++) {
                    const c = this.data[i];
                    const x = toX(i);
                    const isUp = c.c >= c.o;
                    ctx.fillStyle = isUp ? CONFIG.colors.up : CONFIG.colors.down;
                    ctx.strokeStyle = ctx.fillStyle;

                    // Wick
                    ctx.beginPath(); ctx.moveTo(x, toY(c.h)); ctx.lineTo(x, toY(c.l)); ctx.stroke();
                    // Body
                    const yO = toY(c.o); const yC = toY(c.c);
                    ctx.fillRect(x - bodyW/2, Math.min(yO, yC), bodyW, Math.max(1, Math.abs(yO-yC)));
                }

                // E. Draw EWP Labels (Figures Only, No Lines)
                ctx.font = "bold 13px Arial";
                ctx.textAlign = "center";
                
                for(let wave of this.waves) {
                    const color = wave.type === 'bull' ? CONFIG.colors.waveLabelBull : CONFIG.colors.waveLabelBear;
                    const labels = ['1','2','3','4','5'];
                    
                    wave.points.forEach((pt, idx) => {
                        if(pt.i >= startIdx && pt.i <= endIdx) {
                            const x = toX(pt.i);
                            const y = toY(pt.v);
                            const yOffset = wave.type === 'bull' ? -10 : 18;
                            
                            // Draw Text
                            ctx.fillStyle = color;
                            ctx.fillText(labels[idx], x, y + yOffset);
                        }
                    });
                }
                
                // Crosshair
                this.drawCrosshair(toY, pRange, chartW, chartH);
            }

            drawCrosshair(toY, pRange, w, h) {
                const mx = this.input.mouseX; const my = this.input.mouseY;
                if(mx>0 && mx<w && my>0 && my<h) {
                    const ctx = this.dom.ctx;
                    ctx.strokeStyle = '#fff'; ctx.setLineDash([4,4]); ctx.lineWidth=0.5;
                    ctx.beginPath(); ctx.moveTo(0,my); ctx.lineTo(w,my); ctx.moveTo(mx,0); ctx.lineTo(mx,h); ctx.stroke(); ctx.setLineDash([]);

                    // Tooltips
                    const price = this.maxP - ((my/h)*pRange);
                    this.dom.tipP.style.display = 'block';
                    this.dom.tipP.style.top = (my-10)+'px';
                    this.dom.tipP.innerText = price.toFixed(2);
                    
                    // Time Tooltip logic (Approx)
                    // x = chartW - ((endIdx - i + 0.5) * zoom)
                    // Solve for i
                    // ((x - chartW) / -zoom) - 0.5 + endIdx = i
                    const endIdx = this.data.length - 1 - Math.floor(this.view.offset);
                    const iApprox = Math.round(endIdx + 0.5 - ((w - mx) / this.view.zoom));
                    
                    if(this.data[iApprox]) {
                        const d = new Date(this.data[iApprox].t * 1000);
                        this.dom.tipT.style.display = 'block';
                        this.dom.tipT.innerText = d.toLocaleString();
                    }
                } else {
                    this.dom.tipP.style.display = 'none';
                    this.dom.tipT.style.display = 'none';
                }
            }


            // --- 3. INPUTS ---
            initListeners() {
                const c = this.dom.container;
                
                c.addEventListener('mousedown', e => {
                    const rect = c.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    if(x > this.width - CONFIG.paddingRight) {
                        this.input.resizingY = true;
                        this.view.autoScale = false;
                    } else {
                        this.input.dragging = true;
                    }
                    this.input.lastX = e.clientX; this.input.lastY = e.clientY;
                });

                window.addEventListener('mouseup', () => {
                    this.input.dragging = false; this.input.resizingY = false;
                });

                c.addEventListener('mousemove', e => {
                    const rect = c.getBoundingClientRect();
                    this.input.mouseX = e.clientX - rect.left;
                    this.input.mouseY = e.clientY - rect.top;

                    const dx = e.clientX - this.input.lastX;
                    const dy = e.clientY - this.input.lastY;
                    this.input.lastX = e.clientX; this.input.lastY = e.clientY;

                    if(this.input.dragging) {
                        this.view.offset += dx / this.view.zoom;
                        if(this.view.offset < 0) this.view.offset = 0;
                    }
                    if(this.input.resizingY) {
                        this.view.scaleY += dy * -0.01;
                        if(this.view.scaleY < 0.1) this.view.scaleY = 0.1;
                    }
                    this.draw();
                });

                c.addEventListener('wheel', e => {
                    e.preventDefault();
                    const dir = Math.sign(e.deltaY);
                    this.view.zoom += (dir * -1);
                    if(this.view.zoom < 2) this.view.zoom = 2;
                    if(this.view.zoom > 100) this.view.zoom = 100;
                    this.draw();
                }, {passive:false});

                // Double click scale to reset
                c.addEventListener('dblclick', e => {
                    const rect = c.getBoundingClientRect();
                    if(e.clientX - rect.left > this.width - CONFIG.paddingRight) {
                        this.view.autoScale = true; this.view.scaleY = 1.0; this.view.shiftY = 0;
                        this.draw();
                    }
                });

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.width = this.dom.container.clientWidth;
                this.height = this.dom.container.clientHeight;
                this.dom.canvas.width = this.width;
                this.dom.canvas.height = this.height;
                this.draw();
            }

            // --- 4. DATA ---
            async setTF(tf, agg) {
                this.view.tf = tf; this.view.agg = agg;
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                await this.fetchData();
            }

            async fetchData() {
                this.dom.status.innerText = "Loading...";
                try {
                    let ep = 'histominute'; let agg = this.view.agg;
                    if(agg >= 60) { ep = 'histohour'; agg/=60; }
                    if(agg >= 1440) { ep = 'histoday'; agg=1; }
                    
                    const res = await fetch(`https://min-api.cryptocompare.com/data/v2/${ep}?fsym=PAXG&tsym=USD&limit=2000&aggregate=${agg}`);
                    const json = await res.json();
                    
                    if(json.Response === 'Success') {
                        this.data = json.Data.Data.map(d => ({t:d.time, o:d.open, h:d.high, l:d.low, c:d.close}));
                        this.view.offset = 0;
                        
                        this.analyzeEWP(); // Run Strict Analysis
                        this.draw();
                        
                        this.dom.price.innerText = this.data[this.data.length-1].c.toFixed(2);
                        this.dom.status.innerText = "Live";
                    }
                } catch(e) {
                    this.dom.status.innerText = "Offline Mode";
                }
            }
        }

        const app = new ChartApp();

    </script>
</body>
</html>
