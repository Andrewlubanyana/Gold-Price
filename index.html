<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Gold Chart (Resilient)</title>
    <!-- Using Cloudflare CDN for better reliability -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightweight-charts/4.1.1/lightweight-charts.standalone.production.min.js"></script>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: #1e1e1e;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .title-group h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #d4af37; /* Gold */
            letter-spacing: 1px;
        }

        .title-group span {
            font-size: 0.8rem;
            color: #888;
        }

        .price-group {
            text-align: right;
        }

        #current-price {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
        }

        #connection-status {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-live { color: #00e676; } /* Green */
        .status-sim { color: #ff9100; }  /* Orange */
        .status-err { color: #ff1744; }  /* Red */

        #chart-wrapper {
            flex-grow: 1;
            position: relative;
            width: 100%;
        }

        /* Debug Console at the bottom */
        #debug-console {
            height: 100px;
            background: #000;
            color: #00ff00;
            font-family: monospace;
            font-size: 11px;
            padding: 10px;
            overflow-y: auto;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>

    <header>
        <div class="title-group">
            <h1>GOLD / USD</h1>
            <span id="data-source-label">Initializing...</span>
        </div>
        <div class="price-group">
            <div id="current-price">---.--</div>
            <div id="connection-status">Connecting...</div>
        </div>
    </header>

    <div id="chart-wrapper"></div>

    <div id="debug-console">
        <div>> System initialized.</div>
        <div>> Loading Chart Library...</div>
    </div>

    <script>
        // --- UTILITIES ---
        const logDiv = document.getElementById('debug-console');
        function log(msg) {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            logDiv.appendChild(div);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        // --- CHART SETUP ---
        const chartContainer = document.getElementById('chart-wrapper');
        
        let chart;
        let candleSeries;

        try {
            chart = LightweightCharts.createChart(chartContainer, {
                layout: {
                    background: { type: 'solid', color: '#121212' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                    horzLines: { color: 'rgba(42, 46, 57, 0.5)' },
                },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                rightPriceScale: {
                    borderColor: 'rgba(197, 203, 206, 0.8)',
                    autoScale: true,
                },
                timeScale: {
                    borderColor: 'rgba(197, 203, 206, 0.8)',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            candleSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });

            log("Chart Library Loaded Successfully.");
        } catch (e) {
            log("CRITICAL ERROR: Could not load chart library. Check internet.");
        }

        // Handle Window Resize
        new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== chartContainer) return;
            const newRect = entries[0].contentRect;
            chart.applyOptions({ height: newRect.height, width: newRect.width });
        }).observe(chartContainer);


        // --- DATA HANDLING ---
        const elPrice = document.getElementById('current-price');
        const elStatus = document.getElementById('connection-status');
        const elLabel = document.getElementById('data-source-label');
        let lastClose = 0;

        function updateUI(price, isLive) {
            const color = price > lastClose ? '#26a69a' : (price < lastClose ? '#ef5350' : '#fff');
            elPrice.style.color = color;
            elPrice.innerText = `$${price.toFixed(2)}`;
            document.title = `$${price.toFixed(2)} Gold`;
            lastClose = price;
        }

        // --- STRATEGY 1: REAL DATA (CryptoCompare + Binance) ---
        async function startRealData() {
            log("Attempting to fetch real historical data (CryptoCompare)...");
            
            try {
                // Fetch History
                const res = await fetch('https://min-api.cryptocompare.com/data/v2/histominute?fsym=PAXG&tsym=USD&limit=200');
                if (!res.ok) throw new Error("Network response was not ok");
                
                const json = await res.json();
                if (json.Response !== 'Success') throw new Error(json.Message);

                const data = json.Data.Data.map(d => ({
                    time: d.time,
                    open: d.open,
                    high: d.high,
                    low: d.low,
                    close: d.close
                }));

                candleSeries.setData(data);
                lastClose = data[data.length - 1].close;
                updateUI(lastClose, true);
                
                log("History loaded. Connecting to Binance WebSocket...");
                elLabel.innerText = "Source: Real-Time Market Data";
                
                // Connect WebSocket
                const ws = new WebSocket('wss://stream.binance.com:9443/ws/paxgusdt@kline_1m');
                
                ws.onopen = () => {
                    log("WebSocket Connected.");
                    elStatus.innerText = "● LIVE DATA";
                    elStatus.className = "status-live";
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    const k = msg.k;
                    const candle = {
                        time: k.t / 1000,
                        open: parseFloat(k.o),
                        high: parseFloat(k.h),
                        low: parseFloat(k.l),
                        close: parseFloat(k.c),
                    };
                    candleSeries.update(candle);
                    updateUI(candle.close, true);
                };

                ws.onerror = (err) => {
                    log("WebSocket Error. Switching to Simulation.");
                    ws.close();
                    startSimulationMode(lastClose); // Fallback if socket fails
                };

            } catch (err) {
                log(`Real Data Failed: ${err.message}`);
                log("Switching to SIMULATION MODE...");
                // If anything failed, start simulation
                startSimulationMode(2000); // Start sim at $2000
            }
        }

        // --- STRATEGY 2: SIMULATION MODE (Fallback) ---
        // This runs if real API is blocked so the user still sees a chart
        function startSimulationMode(startPrice) {
            elStatus.innerText = "● SIMULATION MODE (Offline)";
            elStatus.className = "status-sim";
            elLabel.innerText = "Source: Generated Data (Demo)";
            log("Generating mock data...");

            // 1. Generate History
            let currentPrice = startPrice;
            const data = [];
            let time = Math.floor(Date.now() / 1000) - (100 * 60); // 100 mins ago

            for (let i = 0; i < 100; i++) {
                const move = (Math.random() - 0.5) * 2;
                const open = currentPrice;
                const close = open + move;
                const high = Math.max(open, close) + Math.random();
                const low = Math.min(open, close) - Math.random();
                
                data.push({ time, open, high, low, close });
                currentPrice = close;
                time += 60;
            }
            
            candleSeries.setData(data);
            updateUI(currentPrice, false);

            // 2. Simulate Live Ticks
            log("Starting simulated live ticks...");
            
            // Keep track of current candle
            let lastCandleTime = time;
            let currentCandle = {
                time: lastCandleTime,
                open: currentPrice,
                high: currentPrice,
                low: currentPrice,
                close: currentPrice
            };

            setInterval(() => {
                const now = Math.floor(Date.now() / 1000);
                
                // New Minute?
                if (now - lastCandleTime >= 60) {
                    lastCandleTime = now;
                    currentCandle = {
                        time: lastCandleTime,
                        open: currentCandle.close,
                        high: currentCandle.close,
                        low: currentCandle.close,
                        close: currentCandle.close
                    };
                }

                const move = (Math.random() - 0.5) * 0.5; // Random small move
                currentCandle.close += move;
                currentCandle.high = Math.max(currentCandle.high, currentCandle.close);
                currentCandle.low = Math.min(currentCandle.low, currentCandle.close);

                candleSeries.update(currentCandle);
                updateUI(currentCandle.close, false);
            }, 1000); // Update every second
        }

        // --- INIT ---
        startRealData();

    </script>
</body>
</html>
