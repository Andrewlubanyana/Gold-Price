<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EWP Gold Chart (Strict & Visible)</title>
    <style>
        /* --- PROFESSIONAL DARK THEME --- */
        body {
            background-color: #000000;
            color: #d1d4dc;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #111;
            border-bottom: 1px solid #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .header-left h1 {
            margin: 0;
            font-size: 16px;
            color: #d4af37; /* Gold */
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-left span {
            font-size: 11px;
            color: #666;
            margin-left: 10px;
        }

        .toolbar {
            display: flex;
            gap: 5px;
        }

        .tf-btn {
            background: #222;
            border: 1px solid #444;
            color: #888;
            padding: 4px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 2px;
            transition: 0.2s;
        }

        .tf-btn:hover { background: #333; color: #fff; }
        .tf-btn.active { background: #d4af37; color: #000; border-color: #d4af37; font-weight: bold; }

        .price-info { text-align: right; }
        .current-price { font-size: 18px; font-weight: bold; color: #fff; }
        .wave-count { font-size: 11px; color: #00b0ff; }

        #chart-area {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Floating Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 100;
            white-space: nowrap;
        }
        #tip-price { right: 0; background: #d4af37; color: #000; font-weight: bold; }
        #tip-time { bottom: 0; border-top: 1px solid #444; }

    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <h1>Gold / USD</h1>
            <span>Strict EWP Scanner</span>
        </div>
        <div class="toolbar">
            <button class="tf-btn active" onclick="app.setTF('1m', 1)">1m</button>
            <button class="tf-btn" onclick="app.setTF('15m', 15)">15m</button>
            <button class="tf-btn" onclick="app.setTF('1h', 60)">1H</button>
            <button class="tf-btn" onclick="app.setTF('4h', 240)">4H</button>
            <button class="tf-btn" onclick="app.setTF('1d', 1440)">1D</button>
        </div>
        <div class="price-info">
            <div class="current-price" id="price-display">---.--</div>
            <div class="wave-count" id="debug-display">Initializing...</div>
        </div>
    </header>

    <div id="chart-area">
        <canvas id="cvs"></canvas>
        <div id="tip-price" class="tooltip"></div>
        <div id="tip-time" class="tooltip"></div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CFG = {
            colors: {
                bg: '#000000',
                grid: '#1a1a1a',
                up: '#089981',
                down: '#f23645',
                text: '#666',
                labelImpulse: '#00b0ff', // Blue for 1-2-3-4-5
                labelCorrect: '#ff9800'  // Orange for A-B-C
            },
            padRight: 60,
            padBottom: 30
        };

        class ChartEngine {
            constructor() {
                this.data = [];
                this.pivots = [];
                this.patterns = [];
                
                this.view = {
                    tf: '1m', agg: 1,
                    offset: 0,
                    zoom: 8, // Candle Width
                    scaleY: 1.0,
                    shiftY: 0,
                    autoScale: true
                };

                this.input = { dragging: false, lastX: 0, lastY: 0, mx: 0, my: 0 };
                
                this.dom = {
                    div: document.getElementById('chart-area'),
                    cvs: document.getElementById('cvs'),
                    ctx: document.getElementById('cvs').getContext('2d', {alpha:false}),
                    price: document.getElementById('price-display'),
                    debug: document.getElementById('debug-display'),
                    tp: document.getElementById('tip-price'),
                    tt: document.getElementById('tip-time'),
                    btns: document.querySelectorAll('.tf-btn')
                };

                this.initListeners();
                this.resize();
                this.fetchData();
            }

            // --- 1. DATA API ---
            async setTF(tf, agg) {
                this.view.tf = tf; this.view.agg = agg;
                this.dom.btns.forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                await this.fetchData();
            }

            async fetchData() {
                this.dom.debug.innerText = "Loading...";
                try {
                    // Using CryptoCompare PAXG (Gold Token)
                    let ep = 'histominute';
                    let agg = this.view.agg;
                    if(agg >= 60) { ep = 'histohour'; agg/=60; }
                    if(agg >= 1440) { ep = 'histoday'; agg=1; }

                    const url = `https://min-api.cryptocompare.com/data/v2/${ep}?fsym=PAXG&tsym=USD&limit=2000&aggregate=${agg}`;
                    const res = await fetch(url);
                    const json = await res.json();

                    if(json.Response === 'Success') {
                        this.data = json.Data.Data.map(d => ({
                            t: d.time, o: d.open, h: d.high, l: d.low, c: d.close
                        }));
                        
                        this.dom.price.innerText = this.data[this.data.length-1].c.toFixed(2);
                        this.view.offset = 0; // Reset to live
                        this.view.autoScale = true;
                        
                        this.analyzeWaves();
                        this.draw();
                    } else {
                        throw new Error("API Error");
                    }
                } catch(e) {
                    this.dom.debug.innerText = "Offline / Simulation Mode";
                    this.generateSimData();
                }
            }

            generateSimData() {
                this.data = [];
                let p = 2000;
                // Generate a clear 5 wave structure for demo
                for(let i=0; i<300; i++) {
                    // Random walk with trend
                    let move = (Math.random()-0.45) * 2; 
                    p += move;
                    this.data.push({t: i*3600, o: p, h: p+1, l: p-1, c: p+move});
                }
                this.analyzeWaves();
                this.draw();
            }

            // --- 2. ELLIOT WAVE ENGINE (Strict) ---
            analyzeWaves() {
                if(this.data.length < 10) return;
                
                // A. Find Pivots (ZigZag)
                // Use a depth-based lookback. A high is a high if it's highest of N bars left and right.
                // We use a small depth (3) to catch smaller waves, relying on logic to filter.
                const depth = 3; 
                this.pivots = [];
                
                for(let i=depth; i<this.data.length-depth; i++) {
                    const cur = this.data[i];
                    
                    // Check High
                    let isH = true;
                    for(let k=1; k<=depth; k++) {
                        if(this.data[i-k].h >= cur.h || this.data[i+k].h >= cur.h) isH = false;
                    }
                    if(isH) this.pivots.push({idx: i, val: cur.h, type: 'H'});

                    // Check Low
                    let isL = true;
                    for(let k=1; k<=depth; k++) {
                        if(this.data[i-k].l <= cur.l || this.data[i+k].l <= cur.l) isL = false;
                    }
                    if(isL) this.pivots.push({idx: i, val: cur.l, type: 'L'});
                }

                // Sort by index just in case
                this.pivots.sort((a,b) => a.idx - b.idx);

                // B. Detect Patterns
                this.patterns = [];
                
                // We scan EVERY pivot as a potential starting point
                for(let i=0; i<this.pivots.length; i++) {
                    this.checkImpulse(i);
                    this.checkCorrection(i);
                }

                // C. Clean Up Overlaps (Optional: For now we show all valid patterns)
                // We filter out very small patterns inside larger ones if they clutter
                this.dom.debug.innerText = `EWP Analysis: ${this.patterns.length} Patterns Found`;
            }

            checkImpulse(startIndex) {
                // Need at least 6 pivots (Start + 5 points)
                if(startIndex + 5 >= this.pivots.length) return;

                const p0 = this.pivots[startIndex];
                const p1 = this.pivots[startIndex+1];
                const p2 = this.pivots[startIndex+2];
                const p3 = this.pivots[startIndex+3];
                const p4 = this.pivots[startIndex+4];
                const p5 = this.pivots[startIndex+5];

                // 1. Alternation Check (Must be H-L-H-L... or L-H-L-H...)
                if(p0.type === p1.type) return; 

                const isBull = p1.val > p0.val;

                if(isBull) {
                    // Structure: Low(0) -> High(1) -> Low(2) -> High(3) -> Low(4) -> High(5)
                    if(p1.type !== 'H' || p2.type !== 'L' || p3.type !== 'H' || p4.type !== 'L' || p5.type !== 'H') return;
                    if(p2.val <= p0.val) return; // Rule 1: W2 can't retrace 100% of W1
                    if(p3.val <= p1.val) return; // W3 must go higher than W1
                    if(p4.val <= p1.val) return; // Rule 3: W4 cannot overlap W1 (Strict)
                    if(p5.val <= p3.val) return; // W5 must go higher (Truncation is rare, ignoring for basic)
                    
                    // Rule 2: W3 not shortest
                    const len1 = Math.abs(p1.val - p0.val);
                    const len3 = Math.abs(p3.val - p2.val);
                    const len5 = Math.abs(p5.val - p4.val);
                    if(len3 < len1 && len3 < len5) return;

                    // Found Bullish Impulse
                    this.patterns.push({
                        type: 'impulse_bull',
                        points: [p1, p2, p3, p4, p5]
                    });

                } else {
                    // Bearish
                    if(p1.type !== 'L' || p2.type !== 'H' || p3.type !== 'L' || p4.type !== 'H' || p5.type !== 'L') return;
                    if(p2.val >= p0.val) return;
                    if(p3.val >= p1.val) return;
                    if(p4.val >= p1.val) return; // Overlap Rule
                    if(p5.val >= p3.val) return;

                    const len1 = Math.abs(p1.val - p0.val);
                    const len3 = Math.abs(p3.val - p2.val);
                    const len5 = Math.abs(p5.val - p4.val);
                    if(len3 < len1 && len3 < len5) return;

                    this.patterns.push({
                        type: 'impulse_bear',
                        points: [p1, p2, p3, p4, p5]
                    });
                }
            }

            checkCorrection(startIndex) {
                // ZigZags (A-B-C) - 3 points after start
                if(startIndex + 3 >= this.pivots.length) return;

                const p0 = this.pivots[startIndex];
                const pa = this.pivots[startIndex+1];
                const pb = this.pivots[startIndex+2];
                const pc = this.pivots[startIndex+3];

                const isBull = pa.val > p0.val; // Correction moving UP (in a downtrend) or simply A-B-C up

                if(isBull) {
                    // A(Up), B(Down), C(Up)
                    if(pa.val <= p0.val) return;
                    if(pb.val <= p0.val) return; // B shouldn't retrace > 100% of A (usually)
                    if(pc.val <= pa.val) return; // C should go above A
                    
                    // Basic geometry: C is often equal to A or 1.618 of A. 
                    // We just check direction here for "Figures" display.
                    
                    // Filter: Ensure it looks corrective (B retraces at least a bit)
                    if(pb.val > pa.val) return;

                    this.patterns.push({
                        type: 'correct_bull',
                        points: [pa, pb, pc]
                    });
                } else {
                    // A(Down), B(Up), C(Down)
                    if(pa.val >= p0.val) return;
                    if(pb.val >= p0.val) return;
                    if(pc.val >= pa.val) return;
                    if(pb.val < pa.val) return;

                    this.patterns.push({
                        type: 'correct_bear',
                        points: [pa, pb, pc]
                    });
                }
            }

            // --- 3. RENDERING ---
            draw() {
                const ctx = this.dom.ctx;
                const W = this.dom.div.clientWidth;
                const H = this.dom.div.clientHeight;
                
                // Background
                ctx.fillStyle = CFG.colors.bg;
                ctx.fillRect(0,0,W,H);

                if(this.data.length === 0) return;

                // A. Viewport Math
                const chartW = W - CFG.padRight;
                const chartH = H - CFG.padBottom;
                const zoom = this.view.zoom;
                
                // Determine visible bars
                const barsVisible = Math.ceil(chartW / zoom);
                let endIdx = this.data.length - 1 - Math.floor(this.view.offset);
                let startIdx = endIdx - barsVisible;
                if(endIdx > this.data.length-1) endIdx = this.data.length-1;
                if(startIdx < 0) startIdx = 0;

                const viewData = this.data.slice(startIdx, endIdx+1);
                
                // Y-Axis Scale
                let min = Infinity, max = -Infinity;
                for(let d of viewData) {
                    if(d.l < min) min = d.l;
                    if(d.h > max) max = d.h;
                }
                
                if(this.view.autoScale) {
                    let pad = (max - min) * 0.15;
                    this.minP = min - pad; this.maxP = max + pad;
                } else {
                    let mid = (min+max)/2 + this.view.shiftY;
                    let rng = (max-min)/this.view.scaleY;
                    this.minP = mid - rng/2; this.maxP = mid + rng/2;
                }
                const pRange = this.maxP - this.minP;

                // Transform Helpers
                const toX = (i) => chartW - ((endIdx - i + 0.5) * zoom);
                const toY = (p) => chartH - ((p - this.minP) / pRange * chartH);

                // B. Draw Grid & Time Axis
                ctx.strokeStyle = CFG.colors.grid;
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                // Price Lines
                for(let i=0; i<6; i++) {
                    let p = this.minP + (pRange * (i/5));
                    let y = toY(p);
                    ctx.moveTo(0,y); ctx.lineTo(chartW,y);
                    // Label
                    ctx.fillStyle = CFG.colors.text;
                    ctx.font = "11px Arial";
                    ctx.fillText(p.toFixed(2), chartW+5, y+4);
                }
                
                // Time Lines & Labels
                let pixelsPerGrid = 120;
                let barsPerGrid = Math.ceil(pixelsPerGrid / zoom);
                
                for(let i=startIdx; i<=endIdx; i++) {
                    // Draw grid approx every N pixels
                    // Align to nearest logical time if possible (simplified here to index)
                    if(i % barsPerGrid === 0) {
                        let x = toX(i);
                        ctx.moveTo(x, 0); ctx.lineTo(x, chartH);
                        
                        // Date Label
                        let date = new Date(this.data[i].t * 1000);
                        let txt = "";
                        if(this.view.tf === '1d') txt = (date.getMonth()+1) + "/" + date.getDate();
                        else txt = date.getHours() + ":" + (date.getMinutes()<10?'0':'') + date.getMinutes();
                        
                        ctx.fillText(txt, x-10, chartH + 15);
                    }
                }
                ctx.stroke();

                // C. Draw Candles
                const bw = Math.max(1, zoom * 0.7);
                for(let i=startIdx; i<=endIdx; i++) {
                    let d = this.data[i];
                    let x = toX(i);
                    let yO = toY(d.o); let yC = toY(d.c);
                    let yH = toY(d.h); let yL = toY(d.l);
                    
                    ctx.fillStyle = d.c >= d.o ? CFG.colors.up : CFG.colors.down;
                    ctx.strokeStyle = ctx.fillStyle;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, yH); ctx.lineTo(x, yL);
                    ctx.stroke();
                    ctx.fillRect(x - bw/2, Math.min(yO, yC), bw, Math.max(1, Math.abs(yO-yC)));
                }

                // D. Draw EWP Labels (Figures Only - No Lines)
                ctx.font = "bold 13px Arial";
                ctx.textAlign = "center";

                // Filter patterns to only show those relevant to current view
                // Optimization: Don't draw labels way off screen
                
                this.patterns.forEach(pat => {
                    let isImpulse = pat.type.includes('impulse');
                    let labels = isImpulse ? ['1','2','3','4','5'] : ['A','B','C'];
                    let color = isImpulse ? CFG.colors.labelImpulse : CFG.colors.labelCorrect;
                    
                    // Check if pattern is visible
                    let visiblePoints = pat.points.filter(p => p.idx >= startIdx && p.idx <= endIdx);
                    if(visiblePoints.length === 0) return;

                    pat.points.forEach((pt, k) => {
                        if(pt.idx >= startIdx && pt.idx <= endIdx) {
                            let x = toX(pt.idx);
                            let y = toY(pt.val);
                            
                            // Offset label slightly
                            let offset = (pt.type === 'H') ? -15 : 20;
                            
                            ctx.fillStyle = color;
                            ctx.fillText(labels[k], x, y + offset);
                        }
                    });
                });

                // E. Crosshair
                if(this.input.mx > 0 && this.input.mx < chartW && this.input.my > 0 && this.input.my < chartH) {
                    ctx.strokeStyle = "#fff";
                    ctx.setLineDash([4,4]);
                    ctx.beginPath();
                    ctx.moveTo(0, this.input.my); ctx.lineTo(chartW, this.input.my);
                    ctx.moveTo(this.input.mx, 0); ctx.lineTo(this.input.mx, chartH);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Tooltips
                    let price = this.maxP - ((this.input.my/chartH) * pRange);
                    this.dom.tp.style.display = 'block';
                    this.dom.tp.style.top = (this.input.my - 10) + "px";
                    this.dom.tp.innerText = price.toFixed(2);
                    
                    // Time
                    let barsFromRight = (chartW - this.input.mx) / zoom;
                    let dataIdx = Math.round(endIdx - barsFromRight + 0.5);
                    if(this.data[dataIdx]) {
                        let d = new Date(this.data[dataIdx].t * 1000);
                        this.dom.tt.style.display = 'block';
                        this.dom.tt.style.left = (this.input.mx - 25) + "px";
                        this.dom.tt.innerText = d.toLocaleString();
                    }
                } else {
                    this.dom.tp.style.display = 'none';
                    this.dom.tt.style.display = 'none';
                }
            }

            // --- 4. INTERACTION ---
            initListeners() {
                const el = this.dom.div;
                
                el.addEventListener('mousedown', e => {
                    const r = el.getBoundingClientRect();
                    const x = e.clientX - r.left;
                    if(x > el.clientWidth - CFG.padRight) {
                        this.view.autoScale = false;
                        el.style.cursor = 'ns-resize';
                    } else {
                        this.input.dragging = true;
                        el.style.cursor = 'grabbing';
                    }
                    this.input.lastX = e.clientX; this.input.lastY = e.clientY;
                });

                window.addEventListener('mouseup', () => {
                    this.input.dragging = false;
                    el.style.cursor = 'crosshair';
                });

                el.addEventListener('mousemove', e => {
                    const r = el.getBoundingClientRect();
                    this.input.mx = e.clientX - r.left;
                    this.input.my = e.clientY - r.top;
                    
                    const dx = e.clientX - this.input.lastX;
                    const dy = e.clientY - this.input.lastY;
                    this.input.lastX = e.clientX; this.input.lastY = e.clientY;

                    if(this.input.dragging) {
                        this.view.offset += dx / this.view.zoom;
                        if(this.view.offset < 0) this.view.offset = 0;
                    } else if(!this.view.autoScale && e.buttons === 1) {
                        // Scale Drag
                        this.view.scaleY += dy * -0.01;
                        if(this.view.scaleY < 0.1) this.view.scaleY = 0.1;
                    }
                    this.draw();
                });

                el.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.view.zoom += (e.deltaY < 0 ? 1 : -1);
                    if(this.view.zoom < 2) this.view.zoom = 2;
                    if(this.view.zoom > 100) this.view.zoom = 100;
                    this.draw();
                }, {passive:false});

                el.addEventListener('dblclick', () => {
                    this.view.autoScale = true; this.view.scaleY = 1.0; this.view.shiftY = 0;
                    this.draw();
                });

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.dom.cvs.width = this.dom.div.clientWidth;
                this.dom.cvs.height = this.dom.div.clientHeight;
                this.draw();
            }
        }

        const app = new ChartEngine();
    </script>
</body>
</html>
