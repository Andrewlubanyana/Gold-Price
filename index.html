<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gold Chart + Automated Elliot Wave</title>
    <style>
        body {
            background-color: #0d0d0d;
            color: #c9c9c9;
            font-family: 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #161616;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a2a;
        }

        .left-panel { display: flex; align-items: center; gap: 20px; }
        
        h1 {
            margin: 0;
            font-size: 18px;
            color: #d4af37;
            font-weight: 700;
        }

        .tf-group {
            display: flex;
            background: #222;
            border-radius: 4px;
            padding: 2px;
        }
        .tf-btn {
            background: transparent;
            border: none;
            color: #777;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
        }
        .tf-btn:hover { color: #fff; background: #333; }
        .tf-btn.active { color: #000; background: #d4af37; }

        .price-panel { text-align: right; }
        #price-main { font-size: 20px; font-weight: bold; color: #fff; }
        #wave-status { font-size: 11px; color: #00b0ff; margin-top: 2px;}

        #chart-wrapper {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* Floating Tooltips */
        #crosshair-label {
            position: absolute;
            right: 0;
            background: #d4af37;
            color: #000;
            padding: 2px 4px;
            font-size: 11px;
            font-weight: bold;
            display: none;
            pointer-events: none;
        }

        #legend {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 10px;
            color: #555;
        }
    </style>
</head>
<body>

    <header>
        <div class="left-panel">
            <h1>GOLD/USD</h1>
            <div class="tf-group">
                <button class="tf-btn active" onclick="app.setTF('1m', 1)">1m</button>
                <button class="tf-btn" onclick="app.setTF('15m', 15)">15m</button>
                <button class="tf-btn" onclick="app.setTF('1h', 60)">1H</button>
                <button class="tf-btn" onclick="app.setTF('4h', 240)">4H</button>
                <button class="tf-btn" onclick="app.setTF('1d', 1440)">1D</button>
            </div>
        </div>
        <div class="price-panel">
            <div id="price-main">---.--</div>
            <div id="wave-status">Calculating Waves...</div>
        </div>
    </header>

    <div id="chart-wrapper">
        <canvas id="cvs"></canvas>
        <div id="crosshair-label"></div>
        <div id="legend">
            <span style="color:#00b0ff">── Swing Structure</span><br>
            <span style="color:#fff">① ② ③ ④ ⑤ Impulse Detected</span>
        </div>
    </div>

    <script>
        /**
         * ELLIOT WAVE & CHART ENGINE
         * 1. Fetches Data
         * 2. Renders Candlesticks
         * 3. Calculates ZigZag Pivots
         * 4. Validates 5-Wave Impulse Rules
         */

        const CONFIG = {
            upColor: '#00e676',
            downColor: '#ff1744',
            bgColor: '#0d0d0d',
            gridColor: '#1f1f1f',
            waveColor: 'rgba(0, 176, 255, 0.6)', // Light Blue for waves
            waveLabelColor: '#ffffff'
        };

        class App {
            constructor() {
                this.data = [];
                this.pivots = []; // The simplified wave points
                this.waves = [];  // Validated 1-2-3-4-5 sequences

                this.state = {
                    timeframe: '1m',
                    apiAgg: 1,
                    scrollOffset: 0,
                    zoom: 15, // Candle width
                    dragging: false,
                    lastX: 0,
                    mouseX: -1,
                    mouseY: -1,
                    width: 0,
                    height: 0
                };

                this.dom = {
                    canvas: document.getElementById('cvs'),
                    ctx: document.getElementById('cvs').getContext('2d', { alpha: false }),
                    container: document.getElementById('chart-wrapper'),
                    price: document.getElementById('price-main'),
                    status: document.getElementById('wave-status'),
                    label: document.getElementById('crosshair-label')
                };

                this.initListeners();
                this.resize();
                this.fetchData();
            }

            // --- ELLIOT WAVE LOGIC ---

            /**
             * 1. Identify Swings (Highs/Lows)
             * Uses a simplified ZigZag approach.
             * Deviation determines how much price must move to form a new leg.
             */
            calculateWaves() {
                if (this.data.length < 10) return;

                // 1. Calculate Pivots (ZigZag)
                // Adjust deviation based on timeframe volatility approximation
                let deviation = 0.05; // 0.05% movement
                if(this.state.timeframe === '1m') deviation = 0.2; // tighter for low TF
                else if(this.state.timeframe === '1h') deviation = 1.5; 
                else if(this.state.timeframe === '1d') deviation = 15.0;

                this.pivots = [];
                
                let direction = 0; // 1 = up, -1 = down
                let lastPivot = this.data[0];
                let lastPivotIdx = 0;

                this.pivots.push({ idx: 0, ...this.data[0], type: 'start' });

                for(let i=1; i<this.data.length; i++) {
                    const c = this.data[i];
                    const changeFromLast = Math.abs(c.c - lastPivot.c);

                    if (direction === 0) {
                        if (c.c > lastPivot.c + deviation) direction = 1;
                        if (c.c < lastPivot.c - deviation) direction = -1;
                        lastPivot = c;
                        lastPivotIdx = i;
                        continue;
                    }

                    if (direction === 1) { // Currently going UP
                        if (c.h > lastPivot.h) {
                            // New High, update current leg tip
                            lastPivot = c;
                            lastPivotIdx = i;
                        } else if (c.c < lastPivot.h - deviation) {
                            // Reversal Detected! Lock in previous high
                            this.pivots.push({ idx: lastPivotIdx, val: lastPivot.h, type: 'high' });
                            direction = -1;
                            lastPivot = c;
                            lastPivotIdx = i;
                        }
                    } else { // Currently going DOWN
                        if (c.l < lastPivot.l) {
                            // New Low, update current leg tip
                            lastPivot = c;
                            lastPivotIdx = i;
                        } else if (c.c > lastPivot.l + deviation) {
                            // Reversal Detected! Lock in previous low
                            this.pivots.push({ idx: lastPivotIdx, val: lastPivot.l, type: 'low' });
                            direction = 1;
                            lastPivot = c;
                            lastPivotIdx = i;
                        }
                    }
                }
                // Add the live candle as the final provisional pivot
                this.pivots.push({ idx: this.data.length-1, val: this.data[this.data.length-1].c, type: 'live' });

                // 2. Identify 1-2-3-4-5 Impulse Patterns
                this.detectImpulseWaves();
            }

            /**
             * 2. Pattern Matcher
             * Iterates through pivots to find sequences matching EW Rules.
             */
            detectImpulseWaves() {
                this.waves = [];
                const p = this.pivots;
                if(p.length < 6) return;

                // Loop through pivots looking for a Start point followed by 5 swings
                for(let i=0; i < p.length - 5; i++) {
                    
                    // Possible points: Start(0), 1(1), 2(2), 3(3), 4(4), 5(5)
                    const start = p[i];
                    const w1 = p[i+1];
                    const w2 = p[i+2];
                    const w3 = p[i+3];
                    const w4 = p[i+4];
                    const w5 = p[i+5];

                    // Check Direction (Must be High-Low-High-Low-High or inverse)
                    const isBullish = w1.val > start.val;
                    if (isBullish && w2.val > w1.val) continue; // Invalid sequence structure

                    // --- ELLIOT WAVE RULES (Bullish Case) ---
                    if (isBullish) {
                        // Rule 1: Wave 2 cannot retrace 100% of Wave 1
                        if (w2.val <= start.val) continue;

                        // Rule 3: Wave 4 cannot enter territory of Wave 1
                        if (w4.val <= w1.val) continue;

                        // Rule 2: Wave 3 cannot be the shortest (Calculations)
                        const len1 = Math.abs(w1.val - start.val);
                        const len3 = Math.abs(w3.val - w2.val);
                        const len5 = Math.abs(w5.val - w4.val);

                        // If 3 is shortest, disqualify
                        if (len3 < len1 && len3 < len5) continue;

                        // Basic Trend Validation (Wave 3 peak higher than Wave 1)
                        if (w3.val <= w1.val) continue;
                        if (w5.val <= w3.val) continue;

                        // If we passed all checks, we have a valid sequence!
                        this.waves.push({
                            type: 'bull',
                            points: [
                                {i: w1.idx, v: w1.val, l: '1'},
                                {i: w2.idx, v: w2.val, l: '2'},
                                {i: w3.idx, v: w3.val, l: '3'},
                                {i: w4.idx, v: w4.val, l: '4'},
                                {i: w5.idx, v: w5.val, l: '5'}
                            ]
                        });
                        
                        // Skip ahead to avoid overlapping conflicting counts
                        i += 4; 
                    }
                    
                    // --- BEARISH RULES (Inverse) ---
                    else {
                        if (w2.val >= start.val) continue; // R1
                        if (w4.val >= w1.val) continue;    // R3
                        
                        const len1 = Math.abs(start.val - w1.val);
                        const len3 = Math.abs(w2.val - w3.val);
                        const len5 = Math.abs(w4.val - w5.val);
                        
                        if (len3 < len1 && len3 < len5) continue; // R2
                        
                        if (w3.val >= w1.val) continue;
                        if (w5.val >= w3.val) continue;

                        this.waves.push({
                            type: 'bear',
                            points: [
                                {i: w1.idx, v: w1.val, l: '①'},
                                {i: w2.idx, v: w2.val, l: '②'},
                                {i: w3.idx, v: w3.val, l: '③'},
                                {i: w4.idx, v: w4.val, l: '④'},
                                {i: w5.idx, v: w5.val, l: '⑤'}
                            ]
                        });
                        i += 4;
                    }
                }
                
                this.dom.status.innerText = `Found ${this.waves.length} Valid Impulse Waves`;
            }


            // --- RENDERING ---

            draw() {
                const ctx = this.dom.ctx;
                const w = this.state.width;
                const h = this.state.height;

                ctx.fillStyle = CONFIG.bgColor;
                ctx.fillRect(0, 0, w, h);

                if (this.data.length === 0) return;

                // 1. Calc Viewport
                const candleW = this.state.zoom;
                const visibleCount = Math.ceil(w / candleW) + 1;
                let endIndex = this.data.length - 1 - Math.floor(this.state.scrollOffset);
                let startIndex = endIndex - visibleCount;
                if(endIndex >= this.data.length) endIndex = this.data.length-1;
                if(startIndex < 0) startIndex = 0;

                // 2. Scale Y-Axis
                let min = Infinity, max = -Infinity;
                for(let i=startIndex; i<=endIndex; i++) {
                    let d = this.data[i];
                    if(d.l < min) min = d.l;
                    if(d.h > max) max = d.h;
                }
                const range = max - min;
                const pMin = min - (range * 0.1);
                const pMax = max + (range * 0.1);
                const pRange = pMax - pMin || 1;
                const toY = (v) => h - ((v - pMin) / pRange * h);
                const toX = (idx) => {
                    const diff = endIndex - idx;
                    return w - (diff * candleW) - (candleW/2);
                };

                // 3. Draw Grid
                ctx.strokeStyle = CONFIG.gridColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for(let i=1; i<6; i++) {
                    let p = pMin + (pRange*(i/6));
                    let y = toY(p);
                    ctx.moveTo(0, y); ctx.lineTo(w, y);
                    ctx.fillStyle = '#444'; ctx.fillText(p.toFixed(2), w-40, y-4);
                }
                ctx.stroke();

                // 4. Draw CANDLES
                const bodyW = Math.max(1, candleW - 1);
                for(let i=startIndex; i<=endIndex; i++) {
                    const c = this.data[i];
                    const x = toX(i);
                    const oY = toY(c.o);
                    const cY = toY(c.c);
                    const hY = toY(c.h);
                    const lY = toY(c.l);
                    
                    const isUp = c.c >= c.o;
                    ctx.fillStyle = isUp ? CONFIG.upColor : CONFIG.downColor;
                    ctx.strokeStyle = ctx.fillStyle;

                    ctx.beginPath(); ctx.moveTo(x, hY); ctx.lineTo(x, lY); ctx.stroke();
                    ctx.fillRect(x - bodyW/2, Math.min(oY, cY), bodyW, Math.max(1, Math.abs(oY-cY)));
                }

                // 5. Draw ELLIOT WAVES (ZigZag Lines)
                ctx.lineWidth = 2;
                ctx.strokeStyle = CONFIG.waveColor;
                ctx.beginPath();
                let first = true;
                
                // Filter pivots that are visible or connected to visible
                for(let i=0; i<this.pivots.length; i++) {
                    const p = this.pivots[i];
                    // Optimization: Only draw if within reasonable range of viewport
                    if(p.idx < startIndex - 20 && this.pivots[i+1]?.idx < startIndex - 20) continue;
                    if(p.idx > endIndex + 20) break;

                    const x = toX(p.idx);
                    const y = toY(p.val);
                    if(first) { ctx.moveTo(x, y); first = false; }
                    else { ctx.lineTo(x, y); }
                }
                ctx.stroke();

                // 6. Draw WAVE LABELS (1, 2, 3, 4, 5)
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                
                this.waves.forEach(wave => {
                    wave.points.forEach(pt => {
                        if(pt.i >= startIndex && pt.i <= endIndex) {
                            const x = toX(pt.i);
                            const y = toY(pt.v);
                            
                            // Background for text
                            ctx.fillStyle = "rgba(0,0,0,0.7)";
                            ctx.beginPath();
                            ctx.arc(x, y, 9, 0, Math.PI*2);
                            ctx.fill();

                            // Text
                            ctx.fillStyle = wave.type === 'bull' ? '#00e676' : '#ff1744';
                            ctx.fillText(pt.l, x, y + 5);
                        }
                    });
                });

                // 7. Crosshair
                if(this.state.mouseX > 0) {
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 0.5;
                    ctx.setLineDash([5,5]);
                    ctx.beginPath();
                    ctx.moveTo(0, this.state.mouseY); ctx.lineTo(w, this.state.mouseY);
                    ctx.moveTo(this.state.mouseX, 0); ctx.lineTo(this.state.mouseX, h);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const price = pMax - ((this.state.mouseY/h)*pRange);
                    this.dom.label.style.display = "block";
                    this.dom.label.style.top = (this.state.mouseY-10)+"px";
                    this.dom.label.innerText = price.toFixed(2);
                } else {
                    this.dom.label.style.display = "none";
                }
            }

            // --- DATA HANDLING ---

            async setTF(tf, agg) {
                this.state.timeframe = tf;
                this.state.apiAgg = agg;
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                await this.fetchData();
            }

            async fetchData() {
                this.dom.status.innerText = "Loading Data...";
                try {
                    // Endpoint Logic
                    let ep = 'histominute';
                    let agg = this.state.apiAgg;
                    if(agg >= 60) { ep = 'histohour'; agg = agg/60; }
                    if(agg >= 24) { ep = 'histoday'; agg = 1; } // Crude simplification for demo

                    const res = await fetch(`https://min-api.cryptocompare.com/data/v2/${ep}?fsym=PAXG&tsym=USD&limit=1000&aggregate=${agg}`);
                    const json = await res.json();
                    
                    if(json.Response !== "Success") throw new Error("API Limit");

                    this.data = json.Data.Data.map(d => ({
                        t: d.time, o: d.open, h: d.high, l: d.low, c: d.close
                    }));
                    
                    // Initial Analysis
                    this.calculateWaves();
                    
                    // Reset View
                    this.state.scrollOffset = 0;
                    const last = this.data[this.data.length-1];
                    this.dom.price.innerText = `$${last.c.toFixed(2)}`;
                    
                    this.draw();

                    // Connect Live Simulation for Updates
                    this.startLiveUpdates();

                } catch (e) {
                    console.log("Fallback to Sim");
                    this.startSimulation();
                }
            }

            startLiveUpdates() {
                if(this.timer) clearInterval(this.timer);
                
                // Simulate ticks (since we are on a static TF snapshot mostly)
                this.timer = setInterval(() => {
                    const last = this.data[this.data.length-1];
                    // Random Walk
                    const move = (Math.random()-0.5) * (this.state.timeframe === '1m' ? 0.5 : 2.0);
                    last.c += move;
                    if(last.c > last.h) last.h = last.c;
                    if(last.c < last.l) last.l = last.c;

                    this.dom.price.innerText = `$${last.c.toFixed(2)}`;
                    this.dom.price.style.color = move > 0 ? CONFIG.upColor : CONFIG.downColor;
                    
                    // RE-CALCULATE WAVES ON EVERY TICK
                    this.calculateWaves(); 
                    this.draw();
                }, 1000);
            }

            startSimulation() {
                // Generate fake data if API fails
                this.data = [];
                let p = 2600;
                for(let i=0; i<500; i++) {
                    let o = p;
                    let c = o + (Math.random()-0.5)*10;
                    this.data.push({t:i, o:o, c:c, h:Math.max(o,c)+1, l:Math.min(o,c)-1});
                    p=c;
                }
                this.calculateWaves();
                this.draw();
            }

            // --- INTERACTION ---
            initListeners() {
                const c = this.dom.container;
                
                c.addEventListener('mousedown', e => {
                    this.state.dragging = true;
                    this.state.lastX = e.clientX;
                    c.style.cursor = 'grabbing';
                });
                
                window.addEventListener('mouseup', () => {
                    this.state.dragging = false;
                    c.style.cursor = 'crosshair';
                });

                c.addEventListener('mousemove', e => {
                    const r = c.getBoundingClientRect();
                    this.state.mouseX = e.clientX - r.left;
                    this.state.mouseY = e.clientY - r.top;

                    if(this.state.dragging) {
                        const dx = e.clientX - this.state.lastX;
                        this.state.lastX = e.clientX;
                        this.state.scrollOffset += dx / this.state.zoom;
                        if(this.state.scrollOffset < 0) this.state.scrollOffset = 0;
                    }
                    this.draw();
                });

                c.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.state.zoom += (e.deltaY < 0 ? 1 : -1);
                    if(this.state.zoom < 3) this.state.zoom = 3;
                    if(this.state.zoom > 100) this.state.zoom = 100;
                    this.draw();
                }, {passive:false});

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const c = this.dom.container;
                this.state.width = c.clientWidth;
                this.state.height = c.clientHeight;
                this.dom.canvas.width = this.state.width;
                this.dom.canvas.height = this.state.height;
                this.draw();
            }
        }

        const app = new App();

    </script>
</body>
</html>
